Okay, a couple of things:
I really like this idea since it keeps a record of free blocks, which is really nice b/c keeps allocation time low. Eventually I want to start back on this method and see if I can make anything of it

#include "MemoryPool.h"
#include <iostream>

#define MINBLOCKSIZE sizeof(header) + 4

// NEVER GET header->freebefore->next or header->freebefore->before UNLESS YOU ARE SURE THAT IT IS NOT NULL


CEGUI::MEMORY::MemoryPool::MemoryPool(int bytes) {
	/*m_ptrStart = new char[bytes];
	header* tempheader = (header*)m_ptrStart;
	tempheader->next = tempheader;
	tempheader->size = 0;
	
	m_ptrFreeMemoryList = tempheader+1;
	m_ptrFreeMemoryList->next = m_ptrFreeMemoryList; // temp header acts as end of list
	m_ptrFreeMemoryList->before = tempheader;
	m_ptrFreeMemoryList->size = bytes - sizeof(header)*2;
	m_ptrFreeMemoryList->freebefore = nullptr; // free blocks don't need this
	m_ptrFreeMemoryListTail = m_ptrFreeMemoryList;
	tempheader->before = m_ptrFreeMemoryList;
	tempheader->freebefore = nullptr;
	
	m_numEntries = 1;
	m_size = bytes;*/
	
}

CEGUI::MEMORY::MemoryPool::~MemoryPool() {
	delete m_ptrStart;
}

// ASSUMPTION 1: THERE WILL NEVER BE TWO OR MORE ADJACENT FREE BLOCKS
void* CEGUI::MEMORY::MemoryPool::allocate(int bytes) {
	/*header* prev, *current;
	current = m_ptrFreeMemoryList;
	prev = m_ptrFreeMemoryListTail;

	bytes = (bytes + 7) & ~7; // multiple of 8 (for byte alignment)
		
	do {
		if (current->size >= bytes) {
			break;
		}
		prev = current;
		current = current->next; // only iterating through free space, super efficient
		if (current == m_ptrFreeMemoryList) {return nullptr;} // no free space :(
	} while(true);
	
	int diff = current->size - bytes;
	
	if (diff > MINBLOCKSIZE) {
		// will be room for another header
		header* newcurrent = (header*)((unsigned char*)(current+1) + bytes);

		if (prev == current) {newcurrent->next = newcurrent;}
		else {newcurrent->next = current->next; prev->next = newcurrent;}
		
		current->size = bytes;
		
		current->next = current->before->next;
		current->before->next = current;

		
		if (current == m_ptrFreeMemoryList) {m_ptrFreeMemoryList = newcurrent; prev = nullptr;}
		if (current == m_ptrFreeMemoryListTail) {m_ptrFreeMemoryListTail = newcurrent;}

		
		current->freebefore = prev;

		newcurrent->size = diff - sizeof(header);
		newcurrent->before = current;
		
		return (void*)(current+1);
	}

	
	if (current == m_ptrFreeMemoryListTail) {m_ptrFreeMemoryListTail = prev;}

	
	if (current == m_ptrFreeMemoryList) {m_ptrFreeMemoryList = current->next; prev = nullptr;}


	
	prev->next = current->next;
	current->next = current->before->next;
	current->frebefore = prev;
	
	return (void*)(current+1);*/
}


// ASSUMPTION 1: THERE WILL NEVER BE TWO OR MORE ADJACENT FREE BLOCKS
// #1 RULE: NEVER LEAVE TWO FREE BLOCKS NEXT TO EACHOTHER, ALWAYS COMBINE THEM!!!!
void CEGUI::MEMORY::MemoryPool::deallocate(void* ptr) {
	/*header* ptrheader = (header*)(ptr) - 1;

	// TODO: FINSIH AND MAKE PRETTY AND SMALL :)
	
	// I don't like all these if's, but what can ya do :/
	
	if (m_ptrFreeMemoryList->before == ptrheader) {
		// if next is at end of list, no way there could be a node before. Delete node, combine & return
		ptrheader->size += m_ptrFreeMemoryList->size;
		//ptrheader->before = m_ptrFreeMemoryList->before;
		ptrheader->next->before = ptrheader;
		ptrheader->before->next = ptrheader->next;

		ptrheader->next = m_ptrFreeMemoryList->next;
		m_ptrFreeMemoryList = ptrheader;
		return;
	}

	if (ptrheader->before == m_ptrFreeMemoryListTail) {
		// now way there could be a free node after. Delete node & return
		m_ptrFreeMemoryListTail += ptrheader->size;
		
		
		ptrheader->next->before = m_ptrFreeMemoryListTail;
		ptrheader->freebefore = nullptr;

		m_ptrFreeMemoryListTail->before->next = ptrheader->next;
		return;
	}
	// freebefore SHOULD NOT BE NULL IF THESE IF's ARE PASSED
	
	if (ptrheader->freebefore == ptrheader->before) {
		// node before

		// Steps
		// next->before needs to = freebefore
		// filled node before ->next = next
		// don't forget to increment size
		
	}
	
	if (ptrheader->freebefore->next < ptrheader->next) {
		// node after
		
		// Steps
		// freebefore->next = ptrheader
		// filled node before ->next = next 
		// dont forget to increment size
		
	}

	// no node before or after
	// ptrheader->next = ptrheader->freebefore->next->next;
	// ptrheader->freebefore->next = ptrheader;
	// ptrheader->freebefore = nullptr;
	
	
	*/
}
